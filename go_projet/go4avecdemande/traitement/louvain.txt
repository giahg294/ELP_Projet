package traitement

import (
	"sort"
	"sync"
)

// Modularity calcule la modularité
func (g *Graph) Modularity() float64 {
	m := float64(0)
	for _, neighbors := range g.AdjList {
		m += float64(len(neighbors))
	}
	m /= 2

	var Q float64
	for node, neighbors := range g.AdjList {
		community := g.Communities[node]
		ki := float64(len(neighbors))
		for _, neighbor := range neighbors {
			kj := float64(len(g.AdjList[neighbor]))
			if g.Communities[neighbor] == community {
				Q += 1.0 - (ki*kj)/(2.0*m)
			}
		}
	}
	return Q / (2 * m)
}

// MergeCommunities fusionne les communautés en un nouveau graphe réduit
func (g *Graph) MergeCommunities() {
	newGraph := NewGraph()
	newCommunities := make(map[int]int)
	communityMap := make(map[int]int)

	// Fusionner les arêtes entre les communautés
	for node, community := range g.Communities {
		for _, neighbor := range g.AdjList[node] {
			// Ne pas fusionner les arêtes dans la même communauté
			if g.Communities[neighbor] != community {
				newGraph.AddEdge(community, g.Communities[neighbor])
			}
		}
		if _, exists := communityMap[community]; !exists {
			communityMap[community] = len(communityMap) + 1
		}
		newCommunities[node] = communityMap[community]
	}

	// Remplacer l'ancien graphe par le nouveau graphe réduit
	*g = *newGraph
	g.Communities = newCommunities
}

// Louvain exécute l'algorithme Louvain avec un nombre spécifié de Goroutines
func (g *Graph) Louvain(maxIterations int, numGoroutines int) {
	nodes := make([]int, 0, len(g.AdjList))
	for node := range g.AdjList {
		nodes = append(nodes, node)
		g.Communities[node] = node
	}
	sort.Ints(nodes)

	for iter := 0; iter < maxIterations; iter++ {
		improvement := false
		var wg sync.WaitGroup
		mu := sync.Mutex{} // Protège g.Communities et improvement

		// Canal pour distribuer les nœuds aux goroutines
		nodeChan := make(chan int, len(nodes))
		for _, node := range nodes {
			nodeChan <- node
		}
		close(nodeChan)

		// Lancer les goroutines
		for i := 0; i < numGoroutines; i++ {
			wg.Add(1)
			go func() {
				defer wg.Done()
				for node := range nodeChan {
					mu.Lock()
					currentCommunity := g.Communities[node]
					mu.Unlock()

					bestCommunity := currentCommunity
					bestModularity := g.localModularity(node, currentCommunity)

					for _, neighbor := range g.AdjList[node] {
						mu.Lock()
						neighborCommunity := g.Communities[neighbor]
						g.Communities[node] = neighborCommunity
						mu.Unlock()

						newModularity := g.localModularity(node, neighborCommunity)
						if newModularity > bestModularity {
							bestModularity = newModularity
							bestCommunity = neighborCommunity
							mu.Lock()
							improvement = true
							mu.Unlock()
						}
					}

					mu.Lock()
					g.Communities[node] = bestCommunity
					mu.Unlock()
				}
			}()
		}
		wg.Wait()

		if !improvement {
			break
		}

		g.MergeCommunities()
	}
}

// localModularity calcule la modularité locale pour un nœud et une communauté donnée
func (g *Graph) localModularity(node, community int) float64 {
	m := float64(0)
	for _, neighbors := range g.AdjList {
		m += float64(len(neighbors))
	}
	m /= 2

	var Q float64
	ki := float64(len(g.AdjList[node]))
	for _, neighbor := range g.AdjList[node] {
		kj := float64(len(g.AdjList[neighbor]))
		if g.Communities[neighbor] == community {
			Q += 1.0 - (ki*kj)/(2.0*m)
		}
	}
	return Q / (2 * m)
}